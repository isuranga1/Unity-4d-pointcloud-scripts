<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Point Cloud Dataset Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            z-index: 1001;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        #sidebar.hidden {
            transform: translateX(-100%);
        }

        #main-content {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #viewer-container {
            flex: 1;
            position: relative;
            min-height: 150px;
        }

        #resizer {
            height: 8px;
            background: #333;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: ns-resize;
            flex-shrink: 0;
            transition: background 0.2s;
        }
        
        #resizer:hover {
            background: #4096ff;
        }

        #video-container {
            height: 200px;
            min-height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            transition: transform 0.3s ease;
        }

        #video-container.hidden {
            transform: translateY(100%);
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 0.3s ease;
        }

        #ui-overlay.panels-hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #focus-hint {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.5;
            color: rgba(255,255,255,0.7);
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Sidebar Styles */
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(64, 150, 255, 0.1);
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #4096ff;
        }

        .folder-upload {
            background: rgba(64, 150, 255, 0.2);
            border: 1px solid rgba(64, 150, 255, 0.4);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: block;
            width: 100%;
            text-align: center;
            transition: all 0.2s;
        }

        .folder-upload:hover {
            background: rgba(64, 150, 255, 0.3);
        }

        .tree-container {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
        }

        .tree-node {
            margin: 2px 0;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 14px;
        }

        .tree-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tree-item.selected {
            background: rgba(64, 150, 255, 0.3);
            border: 1px solid rgba(64, 150, 255, 0.5);
        }
        
        .tree-item-description {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            padding: 2px 8px 8px 44px;
            font-style: italic;
            white-space: normal;
            line-height: 1.4;
            word-break: break-word;
        }

        .tree-icon {
            margin-right: 8px;
            font-size: 12px;
            width: 16px;
            text-align: center;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding-left: 10px;
        }

        .tree-item.folder {
            color: #4096ff;
            font-weight: 500;
        }

        .tree-item.scene {
            color: #52c41a;
        }

        .tree-item.collapsed + .tree-children {
            display: none;
        }

        /* Video Styles */
        #video-player {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
        }

        .video-placeholder {
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-style: italic;
        }

        /* Controls Panel */
        #controls-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            min-width: 500px;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            min-width: 280px;
        }

        #settings-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 200px;
        }

        /* Toggle Buttons for hiding panels */
        #panel-toggles {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 2000;
            pointer-events: auto;
        }

        .toggle-button {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            backdrop-filter: blur(10px);
        }

        .toggle-button:hover {
            background: rgba(64, 150, 255, 0.3);
            border-color: rgba(64, 150, 255, 0.5);
        }

        .toggle-button.active {
            background: rgba(64, 150, 255, 0.2);
            border-color: rgba(64, 150, 255, 0.4);
        }

        .control-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button.active {
            background: rgba(64, 150, 255, 0.3);
            border-color: rgba(64, 150, 255, 0.5);
        }

        #timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #timeline {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        #timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #4096ff, #1890ff);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        #timeline-handle {
            position: absolute;
            top: -6px;
            width: 18px;
            height: 18px;
            background: #4096ff;
            border-radius: 50%;
            cursor: grab;
            transform: translateX(-50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: left 0.1s linear;
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .info-value {
            color: #4096ff;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .slider-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 60px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4096ff;
            border-radius: 50%;
            cursor: pointer;
        }

        #folder-upload {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #4096ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .breadcrumb {
            padding: 10px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .breadcrumb-item {
            color: #4096ff;
        }

        .point-size-value {
            font-size: 12px;
            color: #4096ff;
            min-width: 40px;
            text-align: right;
        }

        /* Keyboard shortcut hint */
        .shortcut-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.1);
            line-height: 1.4;
        }
        
        /* New Styles for Background and Focus Controls */
        .setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }
        .color-swatches {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        .color-swatch:hover {
            transform: scale(1.1);
        }
        .color-swatch.active {
            border-color: #4096ff;
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Dataset Navigator</div>
                <label for="folder-upload" class="folder-upload">üìÅ Load Processed Dataset Folder</label>
                <input type="file" id="folder-upload" webkitdirectory directory>
            </div>
            
            <div class="breadcrumb" id="breadcrumb">
                <span>No dataset loaded</span>
            </div>
            
            <div class="tree-container" id="tree-container">
                <div class="tree-item" style="color: rgba(255,255,255,0.5); font-style: italic;">
                    Load a dataset folder to begin navigation
                </div>
            </div>
        </div>

        <div id="main-content">
            <div id="viewer-container">
                <div id="canvas-container"></div>
                
                <div id="loading" class="loading hidden">
                    <div class="loading-spinner"></div>
                    <div>Loading Point Cloud Data...</div>
                </div>

                <div id="panel-toggles">
                    <div class="toggle-button active" id="toggle-sidebar">üìÇ Sidebar</div>
                    <div class="toggle-button active" id="toggle-panels">üéõÔ∏è Panels</div>
                    <div class="toggle-button active" id="toggle-video">üé• Video</div>
                    <div class="toggle-button" id="toggle-fullscreen">üñ•Ô∏è Fullscreen</div>
                </div>

                <div id="ui-overlay">
                    <div id="info-panel" class="ui-panel">
                        <div class="info-row">
                            <span class="info-label">Scene:</span>
                            <span class="info-value" id="scene-info">None</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Frame:</span>
                            <span class="info-value" id="frame-info">0 / 0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Points:</span>
                            <span class="info-value" id="points-info">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Objects:</span>
                            <span class="info-value" id="objects-info">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">FPS:</span>
                            <span class="info-value" id="fps-info">0</span>
                        </div>
                        <div class="control-button" id="reset-view">üîÑ Reset View</div>
                    </div>

                    <div id="settings-panel" class="ui-panel">
                        <div class="slider-container">
                            <span class="slider-label">Point Size:</span>
                            <input type="range" class="slider" id="point-size" min="0.01" max="2" step="0.01" value="0.3">
                            <span class="point-size-value" id="point-size-value">0.3</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">Speed:</span>
                            <input type="range" class="slider" id="speed-control" min="0.1" max="5" step="0.1" value="1">
                            <span class="point-size-value" id="speed-value">1.0</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">FPS:</span>
                            <input type="range" class="slider" id="fps-control" min="1" max="60" step="1" value="10">
                            <span class="point-size-value" id="fps-value">10</span>
                        </div>

                        <div class="setting-row">
                            <span class="slider-label">Background:</span>
                            <div class="color-swatches">
                                <button class="color-swatch" data-color="0x000000" style="background-color: #000;"></button>
                                <button class="color-swatch active" data-color="0x1a1a1a" style="background-color: #1a1a1a; border: 1px solid #555;"></button>
                                <button class="color-swatch" data-color="0xffffff" style="background-color: #fff;"></button>
                            </div>
                        </div>
                        
                        <!-- *** MODIFIED ***: This button now cycles through all color modes. -->
                        <div class="control-button" id="toggle-color-mode">üé® View: Label</div>
                        <div class="control-button" id="toggle-wireframe">üì¶ Wireframe</div>
                        <div class="control-button" id="toggle-stats">üìä Stats</div>
                        <div class="control-button active" id="toggle-focus-point">üéØ Focus Point</div>
                    </div>

                    <div id="controls-panel" class="ui-panel">
                        <div class="control-button" id="play-pause">
                            <span id="play-icon">‚ñ∂Ô∏è</span>
                            <span id="play-text">Play</span>
                        </div>
                        
                        <div class="control-button" id="prev-frame">‚èÆÔ∏è Prev</div>
                        <div class="control-button" id="next-frame">‚è≠Ô∏è Next</div>
                        
                        <div id="timeline-container">
                            <div id="timeline">
                                <div id="timeline-progress"></div>
                                <div id="timeline-handle"></div>
                            </div>
                            <div class="timeline-labels">
                                <span id="current-time">00:00</span>
                                <span id="total-time">00:00</span>
                            </div>
                        </div>
                    </div>

                    <div id="focus-hint">
                        <b>C</b> + Click to set focus point <br>
                        <b>Right-Click</b> + Drag to pan
                    </div>
                </div>

                <div class="shortcut-hint">
                    <b>H</b> - Toggle panels | <b>S</b> - Toggle sidebar | <b>V</b> - Toggle video | <b>F</b> - Fullscreen
                </div>
            </div>
            
            <div id="resizer"></div>

            <div id="video-container">
                <video id="video-player" class="hidden" muted playsinline>
                    Your browser does not support the video tag.
                </video>
                <div id="video-placeholder" class="video-placeholder">
                    Select a scene to view associated video
                </div>
            </div>
        </div>
    </div>

<script>
    class HierarchicalPointCloudViewer {
        constructor() {
            this.scene = new THREE.Scene();
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.raycaster = new THREE.Raycaster();
            
            this.points = null;
            this.staticPoints = null;
            this.staticFrameData = null; // To store parsed static data for color updates
            this.frames = [];
            this.currentFrame = 0;
            this.isPlaying = false;
            this.fps = 10;
            this.speed = 1.0;
            this.frameInterval = null;
            
            // *** NEW ***: State for color mode now includes 'rgb' and 'normal'
            this.colorMode = 'label'; // Can be 'label', 'rgb', or 'normal'
            
            this.mouse = new THREE.Vector2();
            this.mouseDown = false;
            this.previousMousePosition = new THREE.Vector2();
            
            this.colorMap = this.createColorMap();
            
            this.datasetStructure = {};
            this.currentPath = [];
            this.currentScene = null;

            this.wireframeGroup = new THREE.Group();
            this.showWireframe = false;
            
            this.cameraTarget = new THREE.Vector3(0, 0, 0);
            this.targetIndicator = null;
            this.showFocusPoint = true; 
            this.isCKeyDown = false;
            
            this.isPanning = false;

            this.sidebarVisible = true;
            this.panelsVisible = true;
            this.videoVisible = true;
            
            this.init();
            this.setupControls();
            this.animate();
        }

        init() {
            const viewerContainer = document.getElementById('canvas-container');
            const rect = viewerContainer.getBoundingClientRect();
            this.renderer.setSize(rect.width, rect.height);
            this.renderer.setClearColor(0x1a1a1a, 1);
            viewerContainer.appendChild(this.renderer.domElement);

            this.camera.position.set(5, 5, 5);
            this.camera.lookAt(this.cameraTarget);

            this.scene.background = new THREE.Color(0x1a1a1a);
            
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            this.scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            this.scene.add(directionalLight);

            const axesHelper = new THREE.AxesHelper(2);
            this.scene.add(axesHelper);

            const indicatorGeom = new THREE.SphereGeometry(0.05, 16, 16);
            const indicatorMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
            this.targetIndicator = new THREE.Mesh(indicatorGeom, indicatorMat);
            this.targetIndicator.position.copy(this.cameraTarget);
            this.targetIndicator.visible = this.showFocusPoint;
            this.scene.add(this.targetIndicator);

            this.scene.add(this.wireframeGroup);
            this.wireframeGroup.visible = this.showWireframe;

            document.getElementById('loading').classList.add('hidden');
        }

        setBackgroundColor(color) {
            const bgColor = new THREE.Color(parseInt(color));
            this.scene.background = bgColor;
            this.renderer.setClearColor(bgColor, 1);
        }

        updateCameraAspect() {
            const viewerContainer = document.getElementById('viewer-container');
            if (!viewerContainer) return;
            const rect = viewerContainer.getBoundingClientRect();
            this.camera.aspect = rect.width / rect.height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(rect.width, rect.height);
        }

        createColorMap() {
            return {
                'SMPL': [1.0, 0.2, 0.2], 'character': [1.0, 0.4, 0.0], 'person': [1.0, 0.0, 0.8], 'human': [0.8, 0.0, 1.0],
                'Floor': [0.7, 0.7, 0.7], 'floor': [0.6, 0.6, 0.6], 'Ceiling': [0.9, 0.9, 0.9], 'ceiling': [0.8, 0.8, 0.8],
                'wall': [0.5, 0.5, 0.7], 'Wall': [0.4, 0.4, 0.6], 'chair': [0.6, 0.4, 0.2], 'table': [0.8, 0.6, 0.3],
                'box': [0.3, 0.6, 0.3], 'furniture': [0.5, 0.3, 0.1], 'default': [0.8, 0.8, 0.8], 'f_avg':[0,0,0]
            };
        }

        toggleSidebar() {
            this.sidebarVisible = !this.sidebarVisible;
            document.getElementById('sidebar').classList.toggle('hidden', !this.sidebarVisible);
            document.getElementById('toggle-sidebar').classList.toggle('active', this.sidebarVisible);
        }

        togglePanels() {
            this.panelsVisible = !this.panelsVisible;
            document.getElementById('ui-overlay').classList.toggle('panels-hidden', !this.panelsVisible);
            document.getElementById('toggle-panels').classList.toggle('active', this.panelsVisible);
        }

        toggleVideo() {
            this.videoVisible = !this.videoVisible;
            document.getElementById('video-container').classList.toggle('hidden', !this.videoVisible);
            document.getElementById('resizer').style.display = this.videoVisible ? 'block' : 'none';
            document.getElementById('toggle-video').classList.toggle('active', this.videoVisible);
            setTimeout(() => this.updateCameraAspect(), 300);
        }

        toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => console.error('Error entering fullscreen:', err));
            } else {
                document.exitFullscreen().catch(err => console.error('Error exiting fullscreen:', err));
            }
        }

        async buildDatasetStructure(files) {
            const structure = {};
            for (const file of Array.from(files)) {
                const pathParts = file.webkitRelativePath.split('/');
                if (pathParts.length !== 5) continue;
                
                const [, room, scene, subfolder, filename] = pathParts;

                if (!structure[room]) structure[room] = {};
                if (!structure[room][scene]) {
                    structure[room][scene] = { prompts: {}, staticCloudFile: null };
                }

                if (subfolder.toLowerCase() === 'scene_point_cloud') {
                    if (filename.toLowerCase().match(/\.(ply|xyz|pcd|txt)$/)) {
                        structure[room][scene].staticCloudFile = file;
                    }
                } else if (subfolder.startsWith('prompt_')) {
                    const promptName = subfolder;
                    if (!structure[room][scene].prompts[promptName]) {
                        structure[room][scene].prompts[promptName] = { 
                            pointCloudFiles: [], videoFile: null, descriptionFile: null, description: null 
                        };
                    }
                    const promptData = structure[room][scene].prompts[promptName];
                    if (filename.toLowerCase().match(/\.(ply|xyz|pcd|txt)$/)) {
                        promptData.pointCloudFiles.push(file);
                    } else if (filename.toLowerCase().endsWith('.mp4')) {
                        promptData.videoFile = file;
                    } else if (filename.toLowerCase().endsWith('.json')) {
                        promptData.descriptionFile = file;
                    }
                }
            }
            for (const room in structure) {
                for (const scene in structure[room]) {
                    for (const prompt in structure[room][scene].prompts) {
                        const promptData = structure[room][scene].prompts[prompt];
                        if (promptData.descriptionFile) {
                            try {
                                const jsonContent = await promptData.descriptionFile.text();
                                promptData.description = JSON.parse(jsonContent).description || null;
                            } catch (e) {
                                console.error(`Error parsing JSON for prompt ${prompt}:`, e);
                                promptData.description = "Error reading description.";
                            }
                        }
                        promptData.pointCloudFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                    }
                }
            }
            return structure;
        }

        renderTree() {
            const container = document.getElementById('tree-container');
            container.innerHTML = '';
            for (const [roomName, room] of Object.entries(this.datasetStructure)) {
                const roomNode = this.createTreeNode(roomName, 'folder', 'üìÅ', [roomName]);
                container.appendChild(roomNode);
                const roomChildren = document.createElement('div');
                roomChildren.className = 'tree-children';
                
                for (const [sceneName, sceneData] of Object.entries(room)) {
                    const sceneNode = this.createTreeNode(sceneName, 'folder', 'üé¨', [roomName, sceneName]);
                    roomChildren.appendChild(sceneNode);
                    const sceneChildren = document.createElement('div');
                    sceneChildren.className = 'tree-children';

                    for (const [promptName, promptData] of Object.entries(sceneData.prompts)) {
                        const promptNode = this.createTreeNode(
                            `${promptName} (${promptData.pointCloudFiles.length} frames)`, 
                            'scene',
                            promptData.videoFile ? 'üé•' : 'üìä',
                            [roomName, sceneName, promptName],
                            promptData.description
                        );
                        sceneChildren.appendChild(promptNode);
                    }
                    sceneNode.appendChild(sceneChildren);
                }
                roomNode.appendChild(roomChildren);
            }
        }
        
        createTreeNode(name, type, icon, path, description = null) {
            const node = document.createElement('div');
            node.className = 'tree-node';
            const item = document.createElement('div');
            item.className = `tree-item ${type}`;
            item.innerHTML = `<span class="tree-icon">${icon}</span><span>${name}</span>`;
            if (type === 'scene') {
                item.addEventListener('click', () => this.loadScene(path));
            } else {
                item.addEventListener('click', () => this.toggleFolder(item));
            }
            node.appendChild(item);
            if (description) {
                const descElement = document.createElement('div');
                descElement.className = 'tree-item-description';
                descElement.textContent = description;
                node.appendChild(descElement);
            }
            return node;
        }

        toggleFolder(item) {
            item.classList.toggle('collapsed');
            const icon = item.querySelector('.tree-icon');
            if(icon) {
                 icon.textContent = item.classList.contains('collapsed') 
                    ? icon.textContent.replace('üìÅ', 'üìÇ').replace('üé¨', 'üéûÔ∏è')
                    : icon.textContent.replace('üìÇ', 'üìÅ').replace('üéûÔ∏è', 'üé¨');
            }
        }

        async loadScene(path) {
            const [room, scene, prompt] = path;
            const sceneData = this.datasetStructure[room][scene];
            const promptData = sceneData.prompts[prompt];

            if (!promptData && !sceneData.staticCloudFile) return;
            
            document.getElementById('loading').classList.remove('hidden');
            
            this.frames = [];
            this.staticFrameData = null;
            if (this.points) this.scene.remove(this.points);
            if (this.staticPoints) this.scene.remove(this.staticPoints);
            while(this.wireframeGroup.children.length > 0) this.wireframeGroup.remove(this.wireframeGroup.children[0]);

            this.currentScene = { room, scene, prompt };
            this.updateBreadcrumb(path);
            
            if (sceneData.staticCloudFile) {
                try {
                    this.staticFrameData = await this.parseFile(sceneData.staticCloudFile);
                    if (this.staticFrameData?.pointCount > 0) {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.BufferAttribute(this.staticFrameData.positions, 3));
                        
                        const colorAttribute = this.getColorAttributeForFrame(this.staticFrameData);
                        geometry.setAttribute('color', new THREE.BufferAttribute(colorAttribute, 3));
                        
                        const material = new THREE.PointsMaterial({
                            size: parseFloat(document.getElementById('point-size').value),
                            vertexColors: true, sizeAttenuation: true
                        });
                        this.staticPoints = new THREE.Points(geometry, material);
                        this.scene.add(this.staticPoints);
                    }
                } catch (error) { console.error(`Error loading static point cloud:`, error); }
            }
            
            if (promptData?.pointCloudFiles.length > 0) {
                this.frames = await Promise.all(
                    promptData.pointCloudFiles.map(file => this.parseFile(file).catch(e => {
                        console.error(`Error loading file ${file.name}:`, e); return null;
                    }))
                ).then(frames => frames.filter(f => f !== null));
            }

            document.getElementById('loading').classList.add('hidden');
            
            this.loadVideo(promptData ? promptData.videoFile : null);
            
            if (this.frames.length > 0) {
                this.seekToFrame(0);
            } else {
                this.currentFrame = 0;
                this.updateUI();
            }
            this.resetView(); 
            
            document.getElementById('toggle-wireframe').classList.remove('active');
            this.wireframeGroup.visible = false;
            
            this.updateSelectedTreeItem(path);
        }

        loadVideo(videoFile) {
            const videoPlayer = document.getElementById('video-player');
            const videoPlaceholder = document.getElementById('video-placeholder');
            
            if (this.videoURL) URL.revokeObjectURL(this.videoURL);

            if (videoFile) {
                this.videoURL = URL.createObjectURL(videoFile);
                videoPlayer.src = this.videoURL;
                videoPlayer.classList.remove('hidden');
                videoPlaceholder.classList.add('hidden');
                videoPlayer.pause();
                videoPlayer.currentTime = 0;
            } else {
                videoPlayer.classList.add('hidden');
                videoPlaceholder.classList.remove('hidden');
                videoPlaceholder.textContent = 'No video available for this selection';
            }
        }

        updateBreadcrumb(path) {
            document.getElementById('breadcrumb').innerHTML = path.map(p => `<span class="breadcrumb-item">${p}</span>`).join(' ‚Üí ');
        }

        updateSelectedTreeItem(path) {
            document.querySelectorAll('.tree-item.selected').forEach(item => item.classList.remove('selected'));
            const [, , promptNameFromPath] = path;
            document.querySelectorAll('.tree-item.scene').forEach(item => {
                if (item.textContent.trim().startsWith(promptNameFromPath)) {
                    item.classList.add('selected');
                }
            });
        }

        setupControls() {
            // ... (No changes to camera controls, keeping your implementation)
            const canvas = this.renderer.domElement;
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('mousedown', e => {
                if (e.button === 0) this.mouseDown = true; else if (e.button === 2) this.isPanning = true;
                this.previousMousePosition.set(e.clientX, e.clientY);
            });
            canvas.addEventListener('mouseup', e => {
                if (e.button === 0) this.mouseDown = false; else if (e.button === 2) this.isPanning = false;
            });
            canvas.addEventListener('mousemove', e => {
                if (!this.mouseDown && !this.isPanning) return;
                const delta = new THREE.Vector2(e.clientX - this.previousMousePosition.x, e.clientY - this.previousMousePosition.y);
                if (this.isPanning) {
                    const dist = this.camera.position.distanceTo(this.cameraTarget);
                    const panSpeed = dist * 0.002;
                    const right = new THREE.Vector3().setFromMatrixColumn(this.camera.matrix, 0).multiplyScalar(-delta.x * panSpeed);
                    const up = new THREE.Vector3().setFromMatrixColumn(this.camera.matrix, 1).multiplyScalar(delta.y * panSpeed);
                    this.camera.position.add(right).add(up);
                    this.cameraTarget.add(right).add(up);
                } else if (this.mouseDown) { 
                    const offset = this.camera.position.clone().sub(this.cameraTarget);
                    const spherical = new THREE.Spherical().setFromVector3(offset);
                    spherical.theta -= delta.x * 0.005;
                    spherical.phi -= delta.y * 0.005;
                    spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi));
                    offset.setFromSpherical(spherical);
                    this.camera.position.copy(this.cameraTarget).add(offset);
                    this.camera.lookAt(this.cameraTarget);
                }
                this.targetIndicator.position.copy(this.cameraTarget);
                this.previousMousePosition.set(e.clientX, e.clientY);
            });
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const scale = e.deltaY > 0 ? 1.1 : 0.9;
                this.camera.position.sub(this.cameraTarget).multiplyScalar(scale).add(this.cameraTarget);
            });
            window.addEventListener('keydown', e => { if (e.key.toLowerCase() === 'c') this.isCKeyDown = true; });
            window.addEventListener('keyup', e => { if (e.key.toLowerCase() === 'c') this.isCKeyDown = false; });
            canvas.addEventListener('click', e => {
                if (!this.isCKeyDown) return;
                const objects = [this.points, this.staticPoints].filter(Boolean);
                if (objects.length === 0) return;
                const rect = canvas.getBoundingClientRect();
                this.mouse.set(((e.clientX - rect.left) / rect.width) * 2 - 1, -((e.clientY - rect.top) / rect.height) * 2 + 1);
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(objects);
                if (intersects.length > 0) {
                    this.cameraTarget.copy(intersects[0].point);
                    this.targetIndicator.position.copy(this.cameraTarget);
                    this.camera.lookAt(this.cameraTarget);
                }
            });

            // ... (No changes to resizer logic)
            document.getElementById('resizer').addEventListener('mousedown', e => {
                e.preventDefault();
                const vCont = document.getElementById('video-container'), mCont = document.getElementById('main-content');
                let h = vCont.offsetHeight, y = e.clientY;
                const onMove = me => {
                    let newH = h - (me.clientY - y);
                    newH = Math.max(50, Math.min(mCont.offsetHeight - 150, newH));
                    vCont.style.height = `${newH}px`;
                    this.updateCameraAspect();
                };
                const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
                document.addEventListener('mousemove', onMove);
                document.addEventListener('mouseup', onUp);
            });
            
            document.getElementById('toggle-sidebar').addEventListener('click', () => this.toggleSidebar());
            document.getElementById('toggle-panels').addEventListener('click', () => this.togglePanels());
            document.getElementById('toggle-video').addEventListener('click', () => this.toggleVideo());
            document.getElementById('toggle-fullscreen').addEventListener('click', () => this.toggleFullscreen());
            document.getElementById('play-pause').addEventListener('click', () => this.togglePlayback());
            document.getElementById('prev-frame').addEventListener('click', () => this.previousFrame());
            document.getElementById('next-frame').addEventListener('click', () => this.nextFrame());
            document.getElementById('reset-view').addEventListener('click', () => this.resetView());
            document.getElementById('timeline').addEventListener('click', e => {
                const rect = e.currentTarget.getBoundingClientRect();
                this.seekToFrame(Math.floor(((e.clientX - rect.left) / rect.width) * this.frames.length));
            });
            document.getElementById('point-size').addEventListener('input', e => {
                document.getElementById('point-size-value').textContent = parseFloat(e.target.value).toFixed(2);
                this.updatePointSize(parseFloat(e.target.value));
            });
            document.getElementById('speed-control').addEventListener('input', e => {
                this.speed = parseFloat(e.target.value);
                document.getElementById('speed-value').textContent = this.speed.toFixed(1);
                this.updatePlaybackSpeed();
            });
            document.getElementById('fps-control').addEventListener('input', e => {
                this.fps = parseInt(e.target.value, 10);
                document.getElementById('fps-value').textContent = this.fps;
                if (this.isPlaying) this.startPlayback();
                this.updateUI(); 
            });
            document.getElementById('toggle-wireframe').addEventListener('click', e => {
                this.showWireframe = !this.showWireframe;
                this.wireframeGroup.visible = this.showWireframe;
                e.currentTarget.classList.toggle('active', this.showWireframe);
            });
            
            // *** MODIFIED ***: Event listener for the color mode toggle now cycles through three states.
            document.getElementById('toggle-color-mode').addEventListener('click', e => {
                const button = e.currentTarget;
                if (this.colorMode === 'label') {
                    this.colorMode = 'rgb';
                    button.innerHTML = 'üì∏ View: RGB';
                } else if (this.colorMode === 'rgb') {
                    this.colorMode = 'normal';
                    button.innerHTML = 'üåê View: Normal';
                } else { // was 'normal'
                    this.colorMode = 'label';
                    button.innerHTML = 'üé® View: Label';
                }
                this.updatePointColors();
            });

            document.getElementById('toggle-focus-point').addEventListener('click', e => {
                this.showFocusPoint = !this.showFocusPoint;
                if (this.targetIndicator) this.targetIndicator.visible = this.showFocusPoint;
                e.currentTarget.classList.toggle('active', this.showFocusPoint);
            });
            document.querySelectorAll('.color-swatch').forEach(s => s.addEventListener('click', e => {
                document.querySelector('.color-swatch.active')?.classList.remove('active');
                e.currentTarget.classList.add('active');
                this.setBackgroundColor(e.currentTarget.dataset.color);
            }));
            document.getElementById('folder-upload').addEventListener('change', e => this.loadDataset(e.target.files));
            document.addEventListener('keydown', e => {
                if (e.target.tagName === 'INPUT' || this.isCKeyDown) return;
                const keyMap = { ' ': 'togglePlayback', 'arrowleft': 'previousFrame', 'arrowright': 'nextFrame', 'r': 'resetView', 'h': 'togglePanels', 's': 'toggleSidebar', 'v': 'toggleVideo', 'f': 'toggleFullscreen' };
                const action = keyMap[e.key.toLowerCase()];
                if (action && this[action]) { e.preventDefault(); this[action](); }
            });
            window.addEventListener('resize', () => this.updateCameraAspect());
            document.addEventListener('fullscreenchange', () => {
                const btn = document.getElementById('toggle-fullscreen');
                const isFullscreen = !!document.fullscreenElement;
                btn.classList.toggle('active', isFullscreen);
                btn.innerHTML = isFullscreen ? 'üñºÔ∏è Exit Fullscreen' : 'üñ•Ô∏è Fullscreen';
                setTimeout(() => this.updateCameraAspect(), 100);
            });
        }

        async loadDataset(files) {
            if (!files || files.length === 0) return;
            document.getElementById('loading').classList.remove('hidden');
            try {
                this.datasetStructure = await this.buildDatasetStructure(files);
                this.renderTree();
                document.getElementById('breadcrumb').innerHTML = '<span>Dataset loaded - select a prompt</span>';
            } catch (error) {
                console.error('Error loading dataset:', error);
                document.getElementById('breadcrumb').innerHTML = '<span style="color: #ff4d4f;">Error loading dataset.</span>';
            } finally {
                document.getElementById('loading').classList.add('hidden');
            }
        }
        
        async parseFile(file) {
            const content = await file.text();
            const ext = file.name.split('.').pop().toLowerCase();
            if (ext === 'pcd') return this.parsePCD(content);
            if (ext === 'ply' || ext === 'xyz' || ext === 'txt') {
                 const lines = content.split('\n');
                 let dataStart = 0;
                 if (ext === 'ply') dataStart = lines.findIndex(l => l.trim() === 'end_header') + 1;
                 const positions = [], labels = [];
                 for (let i = dataStart; i < lines.length; i++) {
                     const parts = lines[i].trim().split(/\s+/);
                     if (parts.length >= 3) {
                         const [x,y,z] = parts.slice(0,3).map(parseFloat);
                         if (!isNaN(x)) {
                             positions.push(x,y,z);
                             labels.push(parts.length > 6 ? parts[6] : 'default'); // Assuming label might be further along
                         }
                     }
                 }
                 return this._createDefaultFrameData(positions, labels);
            }
            throw new Error(`Unsupported file format: ${ext}`);
        }
        
        _createDefaultFrameData(positions, labels) {
            const numPoints = positions.length / 3;
            const colors = new Float32Array(numPoints * 3);
            colors.fill(1.0); // Default to white
            const normals = new Float32Array(numPoints * 3);
            for(let i=0; i<numPoints; i++) normals.set([0,1,0], i*3); // Default to up vector
            
            return { 
                positions: new Float32Array(positions), 
                labels, 
                colors,
                normals,
                pointCount: numPoints
            };
        }

        parsePCD(content) {
            const lines = content.split('\n');
            let dataStart = 0, pointCount = 0, dataFormat = 'ascii';
            let fields = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('FIELDS')) fields = line.split(' ').slice(1).map(n => n.toLowerCase());
                else if (line.startsWith('POINTS')) pointCount = parseInt(line.split(' ')[1]);
                else if (line.startsWith('DATA')) {
                    dataFormat = line.split(' ')[1].toLowerCase();
                    dataStart = i + 1;
                    break;
                }
            }
            if (dataFormat !== 'ascii') throw new Error('Only ASCII PCD format is supported');
            
            const positions = [], labels = [], colors = [], normals = [];
            const idx = {
                x: fields.indexOf('x'), y: fields.indexOf('y'), z: fields.indexOf('z'),
                rgb: fields.indexOf('rgb'), 
                label: fields.includes('label') ? fields.indexOf('label') : fields.indexOf('semantic'),
                nx: fields.indexOf('normal_x'), ny: fields.indexOf('normal_y'), nz: fields.indexOf('normal_z')
            };

            for (let i = dataStart; i < dataStart + pointCount && i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                if (parts.length >= 3) {
                    const x = parseFloat(parts[idx.x]), y = parseFloat(parts[idx.y]), z = parseFloat(parts[idx.z]);
                    if (!isNaN(x)) {
                        positions.push(x, y, z);
                        labels.push(idx.label !== -1 && parts[idx.label] ? parts[idx.label] : 'default');
                        
                        if (idx.rgb !== -1) {
                            const packed = parseInt(parts[idx.rgb]);
                            colors.push(((packed >> 16) & 0xFF) / 255, ((packed >> 8) & 0xFF) / 255, (packed & 0xFF) / 255);
                        } else {
                            colors.push(1.0, 1.0, 1.0);
                        }

                        if (idx.nx !== -1) {
                            normals.push(parseFloat(parts[idx.nx]), parseFloat(parts[idx.ny]), parseFloat(parts[idx.nz]));
                        } else {
                            normals.push(0.0, 1.0, 0.0);
                        }
                    }
                }
            }
            return { 
                positions: new Float32Array(positions), 
                labels, 
                colors: new Float32Array(colors),
                normals: new Float32Array(normals),
                pointCount: positions.length / 3 
            };
        }

        getColorForLabel(label) {
            const l = String(label).toLowerCase();
            if (this.colorMap[label]) return this.colorMap[label];
            if (this.colorMap[l]) return this.colorMap[l];
            for (const k in this.colorMap) {
                if (l.includes(k.toLowerCase())) return this.colorMap[k];
            }
            return this.generateColorFromLabel(label);
        }

        generateColorFromLabel(label) {
            let h = 0;
            const s = String(label);
            for (let i = 0; i < s.length; i++) h = Math.imul(31, h) + s.charCodeAt(i) | 0;
            return [(h & 0xFF) / 255, ((h >> 8) & 0xFF) / 255, ((h >> 16) & 0xFF) / 255];
        }
        
        displayFrame(frameIndex) {
            if (frameIndex < 0 || frameIndex >= this.frames.length) return;
            const frameData = this.frames[frameIndex];

            if (this.points) {
                this.scene.remove(this.points);
                this.points.geometry.dispose();
                this.points.material.dispose();
            }
            while(this.wireframeGroup.children.length > 0) {
                const child = this.wireframeGroup.children[0];
                this.wireframeGroup.remove(child);
                if(child.geometry) child.geometry.dispose();
                if(child.material) child.material.dispose();
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(frameData.positions, 3));
            
            const colorAttribute = this.getColorAttributeForFrame(frameData);
            geometry.setAttribute('color', new THREE.BufferAttribute(colorAttribute, 3));

            this.points = new THREE.Points(geometry, new THREE.PointsMaterial({
                size: parseFloat(document.getElementById('point-size').value),
                vertexColors: true,
                sizeAttenuation: true
            }));
            this.scene.add(this.points);
            this.createWireframesForFrame(frameData);
        }

        getColorAttributeForFrame(frameData) {
            switch(this.colorMode) {
                case 'rgb':
                    return frameData.colors;
                case 'normal':
                    return this.generateNormalColors(frameData.normals);
                case 'label':
                default:
                    return this.generateLabelColors(frameData.labels);
            }
        }

        createWireframesForFrame(frameData) {
            const pointsByLabel = new Map();
            for (let i = 0; i < frameData.labels.length; i++) {
                const label = frameData.labels[i];
                if (['default', 'floor', 'wall', 'ceiling'].some(term => String(label).toLowerCase().includes(term))) continue;
                if (!pointsByLabel.has(label)) pointsByLabel.set(label, []);
                pointsByLabel.get(label).push(new THREE.Vector3().fromArray(frameData.positions, i * 3));
            }
            document.getElementById('objects-info').textContent = pointsByLabel.size;
            for (const [label, points] of pointsByLabel.entries()) {
                if (points.length < 2) continue;
                const box = new THREE.Box3().setFromPoints(points);
                if (box.isEmpty()) continue;
                this.wireframeGroup.add(new THREE.Box3Helper(box, new THREE.Color(...this.getColorForLabel(label))));
            }
        }

        generateLabelColors(labels) {
            const c = new Float32Array(labels.length * 3);
            for (let i = 0; i < labels.length; i++) {
                c.set(this.getColorForLabel(labels[i]), i * 3);
            }
            return c;
        }

        generateNormalColors(normals) {
            const colors = new Float32Array(normals.length);
            for (let i = 0; i < normals.length; i++) {
                colors[i] = (normals[i] + 1) / 2; // Map component from [-1, 1] to [0, 1]
            }
            return colors;
        }

        updatePointColors() {
            // Update dynamic points
            if (this.points && this.frames.length > 0 && this.frames[this.currentFrame]) {
                const frameData = this.frames[this.currentFrame];
                const newColors = this.getColorAttributeForFrame(frameData);
                this.points.geometry.setAttribute('color', new THREE.BufferAttribute(newColors, 3));
                this.points.geometry.attributes.color.needsUpdate = true;
            }
            // Update static points
            if (this.staticPoints && this.staticFrameData) {
                 const newStaticColors = this.getColorAttributeForFrame(this.staticFrameData);
                 this.staticPoints.geometry.setAttribute('color', new THREE.BufferAttribute(newStaticColors, 3));
                 this.staticPoints.geometry.attributes.color.needsUpdate = true;
            }
        }

        updatePointSize(size) {
            if (this.points?.material) this.points.material.size = size;
            if (this.staticPoints?.material) this.staticPoints.material.size = size;
        }

        togglePlayback() {
            if (this.frames.length === 0) return;
            this.isPlaying = !this.isPlaying;
            const playIcon = document.getElementById('play-icon');
            const playText = document.getElementById('play-text');
            const video = document.getElementById('video-player');
            
            playIcon.textContent = this.isPlaying ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
            playText.textContent = this.isPlaying ? 'Pause' : 'Play';
            if (this.isPlaying) {
                video.play().catch(e => console.error("Video play failed:", e));
                this.startPlayback();
            } else {
                video.pause();
                this.stopPlayback();
            }
        }

        startPlayback() {
            if (this.frameInterval) clearInterval(this.frameInterval);
            this.frameInterval = setInterval(() => {
                let nextFrame = (this.currentFrame + 1) % this.frames.length;
                if (nextFrame === 0) document.getElementById('video-player')?.load();
                this.seekToFrame(nextFrame);
            }, (1000 / this.fps) / this.speed);
        }

        stopPlayback() {
            clearInterval(this.frameInterval);
            this.frameInterval = null;
        }

        updatePlaybackSpeed() {
            if (this.isPlaying) this.startPlayback();
        }

        nextFrame() {
            if (this.frames.length === 0) return;
            this.seekToFrame((this.currentFrame + 1) % this.frames.length);
        }

        previousFrame() {
            if (this.frames.length === 0) return;
            this.seekToFrame((this.currentFrame - 1 + this.frames.length) % this.frames.length);
        }

        seekToFrame(frameIndex) {
            if (this.frames.length > 0 && (frameIndex < 0 || frameIndex >= this.frames.length)) return;
            
            this.currentFrame = frameIndex;
            if(this.frames.length > 0) this.displayFrame(this.currentFrame);
            this.updateUI();

            const video = document.getElementById('video-player');
            if (video?.readyState > 0 && !video.seeking) {
                video.currentTime = this.currentFrame / this.fps;
            }
        }

        resetView() {
            const combinedBox = new THREE.Box3();
            if (this.staticPoints?.geometry.attributes.position.count > 0) {
                combinedBox.expandByObject(this.staticPoints);
            }
            if (this.points?.geometry.attributes.position.count > 0) {
                combinedBox.expandByObject(this.points);
            }

            if (!combinedBox.isEmpty()) {
                combinedBox.getCenter(this.cameraTarget);
                const size = new THREE.Vector3();
                combinedBox.getSize(size);
                const distance = Math.max(size.x, size.y, size.z) * 1.5;
                this.camera.position.copy(this.cameraTarget).add(new THREE.Vector3(0, distance * 0.5, distance));
            } else {
                this.cameraTarget.set(0, 0, 0);
                this.camera.position.set(5, 5, 5);
            }
            
            this.targetIndicator.position.copy(this.cameraTarget);
            this.camera.lookAt(this.cameraTarget);
        }

        updateUI() {
            if (this.currentScene) document.getElementById('scene-info').textContent = `${this.currentScene.prompt}`;
            document.getElementById('frame-info').textContent = this.frames.length > 0 ? `${this.currentFrame + 1} / ${this.frames.length}` : '0 / 0';
            
            let totalPoints = 0;
            if (this.staticPoints) totalPoints += this.staticPoints.geometry.attributes.position.count;
            if (this.frames.length > 0 && this.frames[this.currentFrame]) totalPoints += this.frames[this.currentFrame].pointCount;
            document.getElementById('points-info').textContent = totalPoints.toLocaleString();
            
            if (this.frames.length > 0) {
                const progress = this.frames.length > 1 ? (this.currentFrame / (this.frames.length - 1)) * 100 : 0;
                document.getElementById('timeline-progress').style.width = `${progress}%`;
                document.getElementById('timeline-handle').style.left = `${progress}%`;
            }
            
            const formatTime = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(Math.floor(s%60)).padStart(2,'0')}`;
            const currentTime = this.frames.length > 0 ? (this.currentFrame / this.fps) : 0;
            const totalTime = this.frames.length > 0 ? ((this.frames.length - 1) / this.fps) : 0;
            document.getElementById('current-time').textContent = formatTime(currentTime);
            document.getElementById('total-time').textContent = formatTime(totalTime);
        }

        animate() {
            requestAnimationFrame(() => this.animate());
            const now = performance.now();
            if (this.lastTime) {
                document.getElementById('fps-info').textContent = Math.round(1000 / (now - this.lastTime));
            }
            this.lastTime = now;
            this.renderer.render(this.scene, this.camera);
        }
    }

    document.addEventListener('DOMContentLoaded', () => new HierarchicalPointCloudViewer());
</script>
</body>
</html>

