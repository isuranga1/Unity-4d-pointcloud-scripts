<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hierarchical Point Cloud Dataset Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            overflow-y: auto;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        #main-content {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent content from spilling out */
        }

        #viewer-container {
            flex: 1; /* Allows the viewer to grow and shrink */
            position: relative;
            min-height: 150px; /* Minimum height for the 3D viewer */
        }

        #resizer {
            height: 8px;
            background: #333;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: ns-resize; /* Vertical resize cursor */
            flex-shrink: 0;
            transition: background 0.2s;
        }
        
        #resizer:hover {
            background: #4096ff;
        }

        #video-container {
            height: 200px; /* Initial height */
            min-height: 50px; /* Minimum resizable height */
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            flex-shrink: 0; /* Prevent the container from shrinking */
            position: relative;
            overflow: hidden;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .ui-panel {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Sidebar Styles */
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(64, 150, 255, 0.1);
        }

        .sidebar-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #4096ff;
        }

        .folder-upload {
            background: rgba(64, 150, 255, 0.2);
            border: 1px solid rgba(64, 150, 255, 0.4);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: block;
            width: 100%;
            text-align: center;
            transition: all 0.2s;
        }

        .folder-upload:hover {
            background: rgba(64, 150, 255, 0.3);
        }

        .tree-container {
            padding: 10px;
            flex: 1;
            overflow-y: auto;
        }

        .tree-node {
            margin: 2px 0;
        }

        .tree-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            font-size: 14px;
        }

        .tree-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .tree-item.selected {
            background: rgba(64, 150, 255, 0.3);
            border: 1px solid rgba(64, 150, 255, 0.5);
        }
        
        .tree-item-description {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            padding: 2px 8px 8px 44px; /* Align with tree item text */
            font-style: italic;
            white-space: normal;
            line-height: 1.4;
            word-break: break-word;
        }

        .tree-icon {
            margin-right: 8px;
            font-size: 12px;
            width: 16px;
            text-align: center;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding-left: 10px;
        }

        .tree-item.folder {
            color: #4096ff;
            font-weight: 500;
        }

        .tree-item.scene {
            color: #52c41a;
        }

        .tree-item.collapsed + .tree-children {
            display: none;
        }

        /* Video Styles */
        #video-player {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
        }

        .video-placeholder {
            color: rgba(255, 255, 255, 0.5);
            text-align: center;
            font-style: italic;
        }

        /* Controls Panel */
        #controls-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            min-width: 500px;
        }

        #info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            min-width: 280px;
        }

        #settings-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            min-width: 200px;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .control-button:active {
            transform: scale(0.95);
        }

        .control-button.active {
            background: rgba(64, 150, 255, 0.3);
            border-color: rgba(64, 150, 255, 0.5);
        }

        #timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #timeline {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        #timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #4096ff, #1890ff);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        #timeline-handle {
            position: absolute;
            top: -6px;
            width: 18px;
            height: 18px;
            background: #4096ff;
            border-radius: 50%;
            cursor: grab;
            transform: translateX(-50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: left 0.1s linear;
        }

        .timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .info-value {
            color: #4096ff;
            font-weight: 500;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .slider-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 60px;
        }

        .slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #4096ff;
            border-radius: 50%;
            cursor: pointer;
        }

        #folder-upload {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 2000;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #4096ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .breadcrumb {
            padding: 10px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .breadcrumb-item {
            color: #4096ff;
        }

        .point-size-value {
            font-size: 12px;
            color: #4096ff;
            min-width: 40px;
            text-align: right;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- Sidebar for navigation -->
        <div id="sidebar">
            <div class="sidebar-header">
                <div class="sidebar-title">Dataset Navigator</div>
                <label for="folder-upload" class="folder-upload">📁 Load Dataset Folder</label>
                <input type="file" id="folder-upload" webkitdirectory directory>
            </div>
            
            <div class="breadcrumb" id="breadcrumb">
                <span>No dataset loaded</span>
            </div>
            
            <div class="tree-container" id="tree-container">
                <div class="tree-item" style="color: rgba(255,255,255,0.5); font-style: italic;">
                    Load a dataset folder to begin navigation
                </div>
            </div>
        </div>

        <!-- Main content area -->
        <div id="main-content">
            <!-- 3D Viewer -->
            <div id="viewer-container">
                <div id="canvas-container"></div>
                
                <div id="loading" class="loading hidden">
                    <div class="loading-spinner"></div>
                    <div>Loading Point Cloud Data...</div>
                </div>

                <div id="ui-overlay">
                    <!-- Info Panel -->
                    <div id="info-panel" class="ui-panel">
                        <div class="info-row">
                            <span class="info-label">Scene:</span>
                            <span class="info-value" id="scene-info">None</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Frame:</span>
                            <span class="info-value" id="frame-info">0 / 0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Points:</span>
                            <span class="info-value" id="points-info">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Objects:</span>
                            <span class="info-value" id="objects-info">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">FPS:</span>
                            <span class="info-value" id="fps-info">0</span>
                        </div>
                        <div class="control-button" id="reset-view">🔄 Reset View</div>
                    </div>

                    <!-- Settings Panel -->
                    <div id="settings-panel" class="ui-panel">
                        <div class="slider-container">
                            <span class="slider-label">Point Size:</span>
                            <input type="range" class="slider" id="point-size" min="0.01" max="2" step="0.01" value="0.3">
                            <span class="point-size-value" id="point-size-value">0.3</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">Speed:</span>
                            <input type="range" class="slider" id="speed-control" min="0.1" max="5" step="0.1" value="1">
                            <span class="point-size-value" id="speed-value">1.0</span>
                        </div>
                        <div class="slider-container">
                            <span class="slider-label">FPS:</span>
                            <input type="range" class="slider" id="fps-control" min="1" max="60" step="1" value="10">
                            <span class="point-size-value" id="fps-value">10</span>
                        </div>
                        <div class="control-button" id="toggle-wireframe">📦 Wireframe</div>
                        <div class="control-button" id="toggle-stats">📊 Stats</div>
                        <div class="control-button" id="use-label-colors">🎨 Label Colors</div>
                    </div>

                    <!-- Controls Panel -->
                    <div id="controls-panel" class="ui-panel">
                        <div class="control-button" id="play-pause">
                            <span id="play-icon">▶️</span>
                            <span id="play-text">Play</span>
                        </div>
                        
                        <div class="control-button" id="prev-frame">⏮️ Prev</div>
                        <div class="control-button" id="next-frame">⏭️ Next</div>
                        
                        <div id="timeline-container">
                            <div id="timeline">
                                <div id="timeline-progress"></div>
                                <div id="timeline-handle"></div>
                            </div>
                            <div class="timeline-labels">
                                <span id="current-time">00:00</span>
                                <span id="total-time">00:00</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Draggable Resizer Handle -->
            <div id="resizer"></div>

            <!-- Video Player -->
            <div id="video-container">
                <video id="video-player" class="hidden" muted playsinline>
                    Your browser does not support the video tag.
                </video>
                <div id="video-placeholder" class="video-placeholder">
                    Select a scene to view associated video
                </div>
            </div>
        </div>
    </div>

    <script>
        class HierarchicalPointCloudViewer {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                
                this.points = null;
                this.frames = [];
                this.currentFrame = 0;
                this.isPlaying = false;
                this.fps = 10;
                this.speed = 1.0;
                this.frameInterval = null;
                this.useLabelColors = true;
                
                this.mouse = new THREE.Vector2();
                this.mouseDown = false;
                this.previousMousePosition = new THREE.Vector2();
                
                this.colorMap = this.createColorMap();
                
                this.datasetStructure = {};
                this.currentPath = [];
                this.currentScene = null;
                
                this.init();
                this.setupControls();
                this.animate();
            }

            init() {
                const viewerContainer = document.getElementById('canvas-container');
                const rect = viewerContainer.getBoundingClientRect();
                this.renderer.setSize(rect.width, rect.height);
                this.renderer.setClearColor(0x0a0a0a, 1);
                viewerContainer.appendChild(this.renderer.domElement);

                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                this.updateCameraAspect();

                this.scene.background = new THREE.Color(0x0a0a0a);
                
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);

                const axesHelper = new THREE.AxesHelper(2);
                this.scene.add(axesHelper);

                document.getElementById('loading').classList.add('hidden');
            }

            updateCameraAspect() {
                const viewerContainer = document.getElementById('viewer-container');
                if (!viewerContainer) return;
                const rect = viewerContainer.getBoundingClientRect();
                this.camera.aspect = rect.width / rect.height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(rect.width, rect.height);
            }

            createColorMap() {
                return {
                    'SMPL': [1.0, 0.2, 0.2], 'character': [1.0, 0.4, 0.0], 'person': [1.0, 0.0, 0.8], 'human': [0.8, 0.0, 1.0],
                    'Floor': [0.7, 0.7, 0.7], 'floor': [0.6, 0.6, 0.6], 'Ceiling': [0.9, 0.9, 0.9], 'ceiling': [0.8, 0.8, 0.8],
                    'wall': [0.5, 0.5, 0.7], 'Wall': [0.4, 0.4, 0.6], 'chair': [0.6, 0.4, 0.2], 'table': [0.8, 0.6, 0.3],
                    'box': [0.3, 0.6, 0.3], 'furniture': [0.5, 0.3, 0.1], 'default': [0.8, 0.8, 0.8]
                };
            }

            async buildDatasetStructure(files) {
                const structure = {};
                const fileArray = Array.from(files);

                for (const file of fileArray) {
                    const pathParts = file.webkitRelativePath.split('/');
                    if (pathParts.length < 5) continue;
                    
                    const [scansFolder, room, prompt, scene, filename] = pathParts;
                    if (!structure[room]) structure[room] = {};
                    if (!structure[room][prompt]) structure[room][prompt] = {};
                    if (!structure[room][prompt][scene]) {
                        structure[room][prompt][scene] = { pointCloudFiles: [], videoFile: null, descriptionFile: null, description: null };
                    }
                    
                    const sceneData = structure[room][prompt][scene];
                    if (filename.toLowerCase().match(/\.(ply|xyz|pcd|txt)$/)) sceneData.pointCloudFiles.push(file);
                    else if (filename.toLowerCase().endsWith('.mp4')) sceneData.videoFile = file;
                    else if (filename.toLowerCase().endsWith('.json')) sceneData.descriptionFile = file;
                }

                for (const room in structure) {
                    for (const prompt in structure[room]) {
                        for (const scene in structure[room][prompt]) {
                            const sceneData = structure[room][prompt][scene];
                            if (sceneData.descriptionFile) {
                                try {
                                    const jsonContent = await sceneData.descriptionFile.text();
                                    const jsonData = JSON.parse(jsonContent);
                                    if (jsonData.description) sceneData.description = jsonData.description;
                                } catch (e) {
                                    console.error(`Error parsing JSON for scene ${scene}:`, e);
                                    sceneData.description = "Error reading description.";
                                }
                            }
                            sceneData.pointCloudFiles.sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true, sensitivity: 'base' }));
                        }
                    }
                }
                return structure;
            }

            renderTree() {
                const container = document.getElementById('tree-container');
                container.innerHTML = '';
                for (const [roomName, room] of Object.entries(this.datasetStructure)) {
                    const roomNode = this.createTreeNode(roomName, 'folder', '📁', [roomName]);
                    container.appendChild(roomNode);
                    const roomChildren = document.createElement('div');
                    roomChildren.className = 'tree-children';
                    for (const [promptName, prompt] of Object.entries(room)) {
                        const promptNode = this.createTreeNode(promptName, 'folder', '📋', [roomName, promptName]);
                        roomChildren.appendChild(promptNode);
                        const promptChildren = document.createElement('div');
                        promptChildren.className = 'tree-children';
                        for (const [sceneName, scene] of Object.entries(prompt)) {
                            const sceneNode = this.createTreeNode(
                                `${sceneName} (${scene.pointCloudFiles.length} files)`, 'scene', 
                                scene.videoFile ? '🎬' : '📊', [roomName, promptName, sceneName], scene.description
                            );
                            promptChildren.appendChild(sceneNode);
                        }
                        promptNode.appendChild(promptChildren);
                    }
                    roomNode.appendChild(roomChildren);
                }
            }
            
            createTreeNode(name, type, icon, path, description = null) {
                const node = document.createElement('div');
                node.className = 'tree-node';
                const item = document.createElement('div');
                item.className = `tree-item ${type}`;
                item.innerHTML = `<span class="tree-icon">${icon}</span><span>${name}</span>`;
                if (type === 'scene') {
                    item.addEventListener('click', () => this.loadScene(path));
                } else {
                    item.addEventListener('click', () => this.toggleFolder(item));
                }
                node.appendChild(item);
                if (description) {
                    const descElement = document.createElement('div');
                    descElement.className = 'tree-item-description';
                    descElement.textContent = description;
                    node.appendChild(descElement);
                }
                return node;
            }

            toggleFolder(item) {
                item.classList.toggle('collapsed');
                const icon = item.querySelector('.tree-icon');
                if (item.classList.contains('collapsed')) {
                    icon.textContent = icon.textContent.replace('📁', '📂').replace('📋', '📄');
                } else {
                    icon.textContent = icon.textContent.replace('📂', '📁').replace('📄', '📋');
                }
            }

            async loadScene(path) {
                const [room, prompt, scene] = path;
                const sceneData = this.datasetStructure[room][prompt][scene];
                if (!sceneData || sceneData.pointCloudFiles.length === 0) return;
                
                document.getElementById('loading').classList.remove('hidden');
                this.frames = [];
                this.currentScene = { room, prompt, scene };
                
                this.updateBreadcrumb(path);
                
                for (const file of sceneData.pointCloudFiles) {
                    try {
                        const frameData = await this.parseFile(file);
                        if (frameData) this.frames.push(frameData);
                    } catch (error) {
                        console.error(`Error loading file ${file.name}:`, error);
                    }
                }
                
                document.getElementById('loading').classList.add('hidden');
                
                this.loadVideo(sceneData.videoFile);
                if (this.frames.length > 0) {
                    this.resetView();
                    this.seekToFrame(0);
                }
                this.updateSelectedTreeItem(path);
            }

            loadVideo(videoFile) {
                const videoPlayer = document.getElementById('video-player');
                const videoPlaceholder = document.getElementById('video-placeholder');
                
                if (this.videoURL) URL.revokeObjectURL(this.videoURL);

                if (videoFile) {
                    this.videoURL = URL.createObjectURL(videoFile);
                    videoPlayer.src = this.videoURL;
                    videoPlayer.classList.remove('hidden');
                    videoPlaceholder.classList.add('hidden');
                    videoPlayer.pause();
                    videoPlayer.currentTime = 0;
                } else {
                    videoPlayer.classList.add('hidden');
                    videoPlaceholder.classList.remove('hidden');
                    videoPlaceholder.textContent = 'No video available for this scene';
                }
            }

            updateBreadcrumb(path) {
                const [room, prompt, scene] = path;
                document.getElementById('breadcrumb').innerHTML = `<span class="breadcrumb-item">${room}</span> → <span class="breadcrumb-item">${prompt}</span> → <span class="breadcrumb-item">${scene}</span>`;
            }

            updateSelectedTreeItem(path) {
                document.querySelectorAll('.tree-item.selected').forEach(item => item.classList.remove('selected'));
                const [,, sceneNameFromPath] = path;
                document.querySelectorAll('.tree-item.scene').forEach(item => {
                    if (item.textContent.trim().startsWith(sceneNameFromPath)) {
                        item.classList.add('selected');
                    }
                });
            }

            setupControls() {
                // Mouse controls for camera
                this.renderer.domElement.addEventListener('mousedown', (event) => {
                    this.mouseDown = true;
                    this.previousMousePosition.set(event.clientX, event.clientY);
                });

                this.renderer.domElement.addEventListener('mouseup', () => {
                    this.mouseDown = false;
                });
                
                // FIXED: This is the corrected mouse move handler
                this.renderer.domElement.addEventListener('mousemove', (event) => {
                    if (!this.mouseDown) return;

                    const deltaMove = new THREE.Vector2(
                        event.clientX - this.previousMousePosition.x,
                        event.clientY - this.previousMousePosition.y
                    );

                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(this.camera.position);
                    
                    spherical.theta -= deltaMove.x * 0.01;
                    spherical.phi += deltaMove.y * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    
                    // The fix is here: separate the two function calls.
                    this.camera.position.setFromSpherical(spherical);
                    this.camera.lookAt(0, 0, 0);

                    this.previousMousePosition.set(event.clientX, event.clientY);
                });

                this.renderer.domElement.addEventListener('wheel', (event) => {
                    event.preventDefault();
                    const scale = event.deltaY > 0 ? 1.1 : 0.9;
                    this.camera.position.multiplyScalar(scale);
                });
                
                const resizer = document.getElementById('resizer');
                const videoContainer = document.getElementById('video-container');
                const mainContent = document.getElementById('main-content');
                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    let h = videoContainer.offsetHeight, y = e.clientY;
                    const onMove = (me) => {
                        let newH = h - (me.clientY - y);
                        newH = Math.max(50, Math.min(mainContent.offsetHeight - 150, newH));
                        videoContainer.style.height = `${newH}px`;
                        this.updateCameraAspect();
                    };
                    const onUp = () => { document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                });


                // UI Controls
                document.getElementById('play-pause').addEventListener('click', () => this.togglePlayback());
                document.getElementById('prev-frame').addEventListener('click', () => this.previousFrame());
                document.getElementById('next-frame').addEventListener('click', () => this.nextFrame());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                
                document.getElementById('timeline').addEventListener('click', (event) => {
                    const rect = event.currentTarget.getBoundingClientRect();
                    const progress = (event.clientX - rect.left) / rect.width;
                    this.seekToFrame(Math.floor(progress * this.frames.length));
                });

                const pointSizeSlider = document.getElementById('point-size');
                pointSizeSlider.addEventListener('input', (e) => {
                    document.getElementById('point-size-value').textContent = parseFloat(e.target.value).toFixed(2);
                    this.updatePointSize(parseFloat(e.target.value));
                });

                const speedSlider = document.getElementById('speed-control');
                speedSlider.addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                    document.getElementById('speed-value').textContent = this.speed.toFixed(1);
                    this.updatePlaybackSpeed();
                });

                const fpsSlider = document.getElementById('fps-control');
                fpsSlider.addEventListener('input', (e) => {
                    this.fps = parseInt(e.target.value, 10);
                    document.getElementById('fps-value').textContent = this.fps;
                    if (this.isPlaying) this.startPlayback();
                    this.updateUI(); 
                });

                document.getElementById('use-label-colors').addEventListener('click', (e) => {
                    this.useLabelColors = !this.useLabelColors;
                    e.currentTarget.classList.toggle('active', this.useLabelColors);
                    e.currentTarget.innerHTML = this.useLabelColors ? '🎨 Label Colors' : '📸 Original Colors';
                    if (this.frames.length > 0) this.displayFrame(this.currentFrame);
                });

                document.getElementById('folder-upload').addEventListener('change', async (e) => await this.loadDataset(e.target.files));

                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    const keyMap = { 'Space': () => this.togglePlayback(), 'ArrowLeft': () => this.previousFrame(), 'ArrowRight': () => this.nextFrame(), 'KeyR': () => this.resetView() };
                    if (keyMap[e.code]) { e.preventDefault(); keyMap[e.code](); }
                });

                window.addEventListener('resize', () => this.updateCameraAspect());
            }

            async loadDataset(files) {
                if (!files || files.length === 0) return;
                document.getElementById('loading').classList.remove('hidden');
                try {
                    this.datasetStructure = await this.buildDatasetStructure(files);
                    this.renderTree();
                    document.getElementById('breadcrumb').innerHTML = '<span>Dataset loaded - select a scene</span>';
                } catch (error) {
                    console.error('Error loading dataset:', error);
                    document.getElementById('breadcrumb').innerHTML = '<span style="color: #ff4d4f;">Error loading dataset.</span>';
                } finally {
                    document.getElementById('loading').classList.add('hidden');
                }
            }
            
            async parseFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const c = e.target.result;
                            const ext = file.name.split('.').pop().toLowerCase();
                            let frameData;
                            if (ext === 'ply') frameData = this.parsePLY(c);
                            else if (ext === 'txt' || ext === 'xyz') frameData = this.parseXYZ(c);
                            else if (ext === 'pcd') frameData = this.parsePCD(c);
                            else reject(new Error('Unsupported file format'));
                            resolve(frameData);
                        } catch (error) { reject(error); }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }
            
            parsePLY(content) {
                const lines = content.split('\n');
                let dataStartIndex = 0;
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i].trim() === 'end_header') {
                        dataStartIndex = i + 1;
                        break;
                    }
                }
                const positions = [];
                const labels = [];
                for (let i = dataStartIndex; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const parts = line.split(/\s+/);
                    if (parts.length >= 3) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        const z = parseFloat(parts[2]);
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            positions.push(x, y, z);
                            labels.push(parts.length > 3 ? parts[3] : 'default');
                        }
                    }
                }
                return { positions: new Float32Array(positions), labels: labels, pointCount: positions.length / 3 };
            }

            parseXYZ(content) {
                const lines = content.split('\n');
                const positions = [];
                const labels = [];
                for (const line of lines) {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length >= 3) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        const z = parseFloat(parts[2]);
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            positions.push(x, y, z);
                            labels.push(parts.length > 3 ? parts[3] : 'default');
                        }
                    }
                }
                return { positions: new Float32Array(positions), labels: labels, pointCount: positions.length / 3 };
            }

            parsePCD(content) {
                const lines = content.split('\n');
                let dataStart = 0, pointCount = 0, dataFormat = 'ascii';
                const fields = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line.startsWith('FIELDS')) fields.push(...line.split(' ').slice(1).map(n => n.toLowerCase()));
                    else if (line.startsWith('POINTS')) pointCount = parseInt(line.split(' ')[1]);
                    else if (line.startsWith('DATA')) {
                        dataFormat = line.split(' ')[1].toLowerCase();
                        dataStart = i + 1;
                        break;
                    }
                }
                if (dataFormat !== 'ascii') throw new Error('Only ASCII PCD format is supported');
                const positions = [], labels = [];
                const xIndex = fields.indexOf('x'), yIndex = fields.indexOf('y'), zIndex = fields.indexOf('z');
                const labelIndex = fields.includes('label') ? fields.indexOf('label') : fields.indexOf('semantic');
                for (let i = dataStart; i < dataStart + pointCount && i < lines.length; i++) {
                    const parts = lines[i].trim().split(/\s+/);
                    if (parts.length >= 3) {
                        const x = parseFloat(parts[xIndex]), y = parseFloat(parts[yIndex]), z = parseFloat(parts[zIndex]);
                        if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                            positions.push(x, y, z);
                            labels.push(labelIndex !== -1 && parts[labelIndex] ? parts[labelIndex] : 'default');
                        }
                    }
                }
                return { positions: new Float32Array(positions), labels: labels, pointCount: positions.length / 3 };
            }

            getColorForLabel(label) {
                const l = String(label).toLowerCase();
                if (this.colorMap[label]) return this.colorMap[label];
                if (this.colorMap[l]) return this.colorMap[l];
                for (const k in this.colorMap) {
                    if (l.includes(k.toLowerCase())) return this.colorMap[k];
                }
                return this.generateColorFromLabel(label);
            }

            generateColorFromLabel(label) {
                let h = 0;
                const s = String(label);
                for (let i = 0; i < s.length; i++) {
                    h = ((h << 5) - h) + s.charCodeAt(i);
                    h &= h;
                }
                return [(h & 0xFF) / 255, ((h >> 8) & 0xFF) / 255, ((h >> 16) & 0xFF) / 255];
            }
            
            displayFrame(frameIndex) {
                if (frameIndex < 0 || frameIndex >= this.frames.length) return;
                const frameData = this.frames[frameIndex];
                if (this.points) {
                    this.scene.remove(this.points);
                    this.points.geometry.dispose();
                    this.points.material.dispose();
                }
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(frameData.positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(this.generateLabelColors(frameData.labels), 3));
                const material = new THREE.PointsMaterial({
                    size: parseFloat(document.getElementById('point-size').value),
                    vertexColors: true,
                    sizeAttenuation: true
                });
                this.points = new THREE.Points(geometry, material);
                this.scene.add(this.points);
            }

            generateLabelColors(labels) {
                const c = new Float32Array(labels.length * 3);
                for (let i = 0; i < labels.length; i++) {
                    const ca = this.getColorForLabel(labels[i]);
                    c[i * 3] = ca[0];
                    c[i * 3 + 1] = ca[1];
                    c[i * 3 + 2] = ca[2];
                }
                return c;
            }

            updatePointSize(size) {
                if (this.points?.material) {
                    this.points.material.size = size;
                }
            }

            togglePlayback() {
                if (this.frames.length === 0) return;
                this.isPlaying = !this.isPlaying;
                const playIcon = document.getElementById('play-icon');
                const playText = document.getElementById('play-text');
                const video = document.getElementById('video-player');
                
                if (this.isPlaying) {
                    playIcon.textContent = '⏸️';
                    playText.textContent = 'Pause';
                    video.play().catch(e => console.error("Video play failed:", e));
                    this.startPlayback();
                } else {
                    playIcon.textContent = '▶️';
                    playText.textContent = 'Play';
                    video.pause();
                    this.stopPlayback();
                }
            }

            startPlayback() {
                if (this.frameInterval) clearInterval(this.frameInterval);
                const interval = (1000 / this.fps) / this.speed;
                this.frameInterval = setInterval(() => {
                    let nextFrame = this.currentFrame + 1;
                    if (nextFrame >= this.frames.length) {
                        nextFrame = 0;
                        const video = document.getElementById('video-player');
                        if (video) video.currentTime = 0;
                    }
                    this.seekToFrame(nextFrame);
                }, interval);
            }

            stopPlayback() {
                if (this.frameInterval) clearInterval(this.frameInterval);
                this.frameInterval = null;
            }

            updatePlaybackSpeed() {
                if (this.isPlaying) this.startPlayback();
            }

            nextFrame() {
                if (this.frames.length === 0) return;
                this.seekToFrame((this.currentFrame + 1) % this.frames.length);
            }

            previousFrame() {
                if (this.frames.length === 0) return;
                this.seekToFrame(this.currentFrame === 0 ? this.frames.length - 1 : this.currentFrame - 1);
            }

            seekToFrame(frameIndex) {
                if (frameIndex < 0 || frameIndex >= this.frames.length) return;
                
                this.currentFrame = frameIndex;
                this.displayFrame(this.currentFrame);
                this.updateUI();

                const video = document.getElementById('video-player');
                const timeInSeconds = this.currentFrame / this.fps;

                if (video && video.readyState > 0 && !video.seeking) {
                    video.currentTime = timeInSeconds;
                }
            }

            resetView() {
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
            }

            updateUI() {
                if (this.currentScene) document.getElementById('scene-info').textContent = `${this.currentScene.scene}`;
                document.getElementById('frame-info').textContent = `${this.currentFrame + 1} / ${this.frames.length}`;
                if (this.frames[this.currentFrame]) document.getElementById('points-info').textContent = this.frames[this.currentFrame].pointCount.toLocaleString();
                
                if (this.frames.length > 0) {
                    const progress = this.frames.length > 1 ? (this.currentFrame / (this.frames.length - 1)) * 100 : 0;
                    document.getElementById('timeline-progress').style.width = `${progress}%`;
                    document.getElementById('timeline-handle').style.left = `${progress}%`;
                }
                
                const currentTime = this.frames.length > 0 ? (this.currentFrame / this.fps) : 0;
                const totalTime = this.frames.length > 0 ? ((this.frames.length - 1) / this.fps) : 0;
                document.getElementById('current-time').textContent = this.formatTime(currentTime);
                document.getElementById('total-time').textContent = this.formatTime(totalTime);
            }

            formatTime(seconds) {
                const totalSecs = Math.floor(seconds);
                const mins = Math.floor(totalSecs / 60);
                const secs = totalSecs % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const now = performance.now();
                if (this.lastTime) {
                    const delta = now - this.lastTime;
                    if (delta > 0) document.getElementById('fps-info').textContent = Math.round(1000 / delta);
                }
                this.lastTime = now;
                this.renderer.render(this.scene, this.camera);
            }
        }

        document.addEventListener('DOMContentLoaded', () => new HierarchicalPointCloudViewer());
    </script>
</body>
</html>
